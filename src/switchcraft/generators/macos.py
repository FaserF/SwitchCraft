import textwrap
import uuid
from typing import Optional, Dict
from switchcraft.models import InstallerInfo

def generate_intune_script(
    info: InstallerInfo,
    install_cmd: Optional[str] = None,
    uninstall_cmd: Optional[str] = None,
    pre_install: str = "",
    post_install: str = "",
    log_file_path: str = "/Library/Logs/Microsoft/IntuneScripts/install.log"
) -> str:
    """
    Generates an Intune-compatible bash script for MacOS.
    """

    app_name = info.product_name or "Unknown App"
    bundle_id = info.bundle_id or "com.unknown.app"
    version = info.product_version or "1.0"

    # Auto-detect install command if not provided
    if not install_cmd:
        filename = info.file_path.split('\\')[-1].split('/')[-1] # handle windows paths in string
        if info.installer_type == "MacOS PKG":
            install_cmd = f'installer -pkg "{filename}" -target /'
        elif info.installer_type == "MacOS DMG":
            # Basic DMG mount and copy sample
            install_cmd = textwrap.dedent(f'''
                # Mount DMG
                hdiutil attach "{filename}" -nobrowse -mountpoint /Volumes/tmp_mount
                # Copy App
                cp -R "/Volumes/tmp_mount/*.app" /Applications/
                # Detach
                hdiutil detach /Volumes/tmp_mount
            ''').strip()
        else:
            install_cmd = f"# Install command for {filename} (Manual configuration required)"

    from switchcraft import __version__
    script = f"""#!/bin/bash
# ==============================================================================
#  AppName: {app_name}
#  Version: {version}
#  BundleID: {bundle_id}
#  Generated by SwitchCraft v{__version__}
#  GitHub: https://github.com/FaserF/SwitchCraft
# ==============================================================================

set -e  # Exit strictly on error
set -o pipefail

# Logging
LOG_FILE="{log_file_path}"
mkdir -p "$(dirname "$LOG_FILE")"

log() {{
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [INFO] $1" | tee -a "$LOG_FILE"
}}

log_error() {{
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [ERROR] $1" | tee -a "$LOG_FILE" >&2
}}

# Trap for clean exit or error logging
cleanup() {{
    EXIT_CODE=$?
    if [ $EXIT_CODE -ne 0 ]; then
        log_error "Script exited with error code $EXIT_CODE"
    fi
    log "Finished."
}}
trap cleanup EXIT

log "Starting installation of {app_name} ({version})..."
log "User: $(whoami)"

# Metadata Information (for Intune reference)
# INTUNE_APP_ID: {bundle_id}
# INTUNE_APP_VERSION: {version}
"""
    if info.package_ids:
        script += "# Package IDs found:\n"
        for pid in info.package_ids:
            script += f"# - {pid}\n"

    script += f"""
# Pre-install steps
if [ -n "{pre_install}" ]; then
    log "Running pre-install steps..."
    {pre_install}
fi

# Installation
log "Executing install command: {install_cmd}"
{install_cmd}

log "Installation successful."

# Post-install steps
if [ -n "{post_install}" ]; then
    log "Running post-install steps..."
    {post_install}
fi
"""
    return script

def generate_mobileconfig(
    identifier: str,
    display_name: str,
    payload_type: str = "com.apple.security.firewall", # Example default
    payload_content: Dict = None,
    organization: str = "Organization Name",
    description: str = "Generated by SwitchCraft"
) -> str:
    """
    Generates a simple .mobileconfig XML.
    """
    payload_uuid = str(uuid.uuid4())
    top_uuid = str(uuid.uuid4())

    # Construct PayloadContent XML manually or via plistlib?
    # XML construction is safer for mobileconfig structure validation if we want specific ordering,
    # but plistlib is standard. Let's use string template for flexibility with unknown dicts.

    # Taking a simplistic approach for now:
    # We will assume user wants a skeleton or specific payloads.

    # Check if payload_content is provided, otherwise generic example

    if payload_content:
        # Convert dict to simple plist key-values
        # This is a very basic converter, might need proper plistlib dump if complex
        pass # To be implemented if we want full dict to xml conversion

    # Standard header
    xml = f"""<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>PayloadContent</key>
    <array>
        <dict>
            <key>PayloadDescription</key>
            <string>{description}</string>
            <key>PayloadDisplayName</key>
            <string>{display_name}</string>
            <key>PayloadIdentifier</key>
            <string>{identifier}.payload</string>
            <key>PayloadType</key>
            <string>{payload_type}</string>
            <key>PayloadUUID</key>
            <string>{payload_uuid}</string>
            <key>PayloadVersion</key>
            <integer>1</integer>
            <!-- Add specific settings here -->
        </dict>
    </array>
    <key>PayloadDisplayName</key>
    <string>{display_name}</string>
    <key>PayloadIdentifier</key>
    <string>{identifier}</string>
    <key>PayloadOrganization</key>
    <string>{organization}</string>
    <key>PayloadType</key>
    <string>Configuration</string>
    <key>PayloadUUID</key>
    <string>{top_uuid}</string>
    <key>PayloadVersion</key>
    <integer>1</integer>
</dict>
</plist>
"""
    return xml
